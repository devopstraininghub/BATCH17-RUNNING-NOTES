SHELL SCRIPT :


[root@linux opt]# cat ./devopesenginner.sh


#!/bin/bash



echo "Enter the DevOps engineer Name:"
read Name
mkdir $Name
cd $Name
touch linux
touch jenkins
touch ansible
touch k8s
mkdir aws
cd aws
touch ec2
touch efs
touch eks
touch route53
touch s3


[root@linux opt]#
===========================================================
5 JAN 2026:

WHAT IS SHELL SCRIPT & WHY SHELL SCRIPT ?

A shell script is a file with a set of shell commands , for Automation of Repetetive tasks . (extention with .sh ) 

What is a variable ?

a variable is a charecter string to which we assign a value. The value assigned could be a number , text , filename , device or any other type of Data .  Simply its a pointer / reference to actual data .


SHELL SCRIPTING  FOR   AUTOMATION & TO MINIMIZE REPETETIVE TASKS 

===================================
HASH-BANG  OR SHEBANG

#!/bin/bash
#!/bin/sh
#!/bin/dash


The shebang line, 
starts with #! followed by the path to the interpreter that should be used to execute the script. 



===========================

vim jenkinssetup.sh

#!/bin/bash

 cat jenkinssetup.sh
#!/bin/bash

##################
###  Author : Madhukiran
#### Date: 5 JAN 2026
#### Version : V1
#### Purpose: To setup Jenkins

sudo yum update –y
sudo wget -O /etc/yum.repos.d/jenkins.repo  https://pkg.jenkins.io/redhat-stable/jenkins.repo
sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key
sudo yum upgrade
sudo yum install java-21-amazon-corretto -y
sudo yum install jenkins -y
sudo systemctl enable jenkins
sudo systemctl start jenkins

==========================================================

vim tomcatsetup.sh


#!/bin/bash


#############################
#    SCRIPT DATA:
# AUTHOR: MADHU
#

cd /opt
yum install java -y
wget https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.113/bin/apache-tomcat-9.0.113.tar.gz
tar -xvf /opt/apache-tomcat-9.0.113.tar.gz
/opt/apache-tomcat-9.0.113/bin/startup.sh



==========================================================

set -x ---> debug mode 

bash -x devopsengineer.sh

set -e  ( Exit on error) 
====================================================

COMMAND LINE ARGUMENTS:

 cat test.sh


#!/bin/bash

#set -x

echo "script Name: $0"
echo "FIRST Name: $1"
echo "second Argument: $2"

============================

[root@linux opt]# cat devopsengineer_CLA.sh
#!/bin/bash

##########################
# NAME : devops engineer profile setup
# Date: 5 jan 2025
# Author: Madhukiran
# Version: v1
###########################################

set -x
set -e

#echo "Enter the DevOps engineer Name:"
#read Name
mkdir $1
cd $1
touch linux
touch jenkins
touch ansible
touch k8s
mkdir aws
cd aws
touch ec2
touch efs
touch eks
touch route53
touch s3
========================================================================

DATE: 6 JAN 25

==================================================

Debugging / Troubleshooting :
 

set -x  
    Turn on debugging.prints each command before it is executed.

set +x  
    Turn off debugging
	
--------
set -e  
    Exit on error , Useful for error handling; exits the script immediately if any command fails.

   Causes the script to exit immediately if any command exits with a non-zero status (indicating an error).
   
---------------
   
==================================================================================================================
COMMANDLINE ARGUMENTS / POSTITIONAL ARGUMENTS / COMMANDLINE VARIABLES/SPECIAL VARIABLES 

[root@linux opt]# cat cla.sh

#!/bin/bash

echo "The name of this script is: $0"
echo "The first argument is: $1"
echo "The second argument is: $2"
echo "Number of arguments passed: $#"
echo "All the arguments passed - as SINGLE word: $*"
echo "All the arguments passed - as individual words: $@"
echo "Exit status is: $?"
===============================================================================
to understand diffrence between $* vs $@

cat diff.sh 


#!/bin/bash

for i in "$*"; 
#for i in "$@";   
do
    echo $i
done

================================================================================
command to get tomcat process id:
ps -ef | grep tomcat | awk -F" " '{print $2}' | head -1

----------------------------
cat tomcatsetup.sh


#!/bin/bash
#############################
#    SCRIPT DATA:
# AUTHOR: MADHU
#

cd /opt
yum install java -y
wget https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.113/bin/apache-tomcat-9.0.113.tar.gz
tar -xvf /opt/apache-tomcat-9.0.113.tar.gz
/opt/apache-tomcat-9.0.113/bin/startup.sh

echo "THE TOMCAT PROCESS ID IS :"
ps -ef | grep tomcat | awk -F" " '{print $2}' | head -1


===============================================================================
[root@linux opt]# cat sum.sh

#!/bin/bash

echo "ENTER THE 1ST NUMBER"

read num1

echo "ENTER THE 2nd NUMBER"

read num2

sum=$(( num1 + num2 ))

echo " The sum of 2 numbers : sum"

---------------------------------------------------
[root@linux opt]# cat subtraction.sh



#!/bin/bash

#echo "ENTER THE 1ST NUMBER"

num1=$1
num2=$2

#echo "ENTER THE 2nd NUMBER"

#read num2

output=$(( num1 - num2 ))

echo " The output is : $output"

------------------------------------------------------


Variables:

LOCAL VARIABLES 
ENVIRONMENT var
SHELL VAR


LOCAL VARIABLES: Defined within a specific function or script. They are temporary and only accessible within their scope.

ENVIRONMENT VARIABLEs: Set using export, available system-wide, and accessible by any child process.

SHELL VARIABLES: Defined in the current shell session. If not exported, they are not accessible to child processes.

-------------------------

How to read a  variable :

read name 
--------------------------------------
How to unset a variabl e

unset name  
-------------------------------------------
vim unsetex.sh

#!/bin/bash

name="Madhu kiran"

echo $name        
                    
unset name        

echo $name  # Output: (nothing, the variable is unset)

=================================================
ENVIRONMENT VARIABLES :

These varibales are dynamic 
environment variables provide a way to customize the behavior of software and the operating system itself.

User specific environemnt variables .

How to check environment variables in windows os and Linux OS.
& how to configure in both WINDOWS  & LINUX OS

   env
   echo HOSTNAME
   echo $HOSTNAME
   env | grep USER
   echo $USER
   echo USER
   export TESTNAME=testmadhu
   echo $USER
   printenv USER
   export COLOR=blune
   env
   export VAR=testmadhu
   env | grep COLOR
   printenv VAR
   printenv COLOR
   echo $VAR
   
removing environment variable using unset:    
   unset COLOR
   printenv COLOR
   
====================================================
[root@linux opt]# cat unset.sh
#!/bin/bash

name="Madhu kiran"

echo "printing variable: $name"

unset name

echo "printing variable: $name"  # Output: (nothing, the variable is unset)


===========================================================

DATE: 7 JAN 26
================================================================
CONDITIONAL EXPRESSION : 


if [ condition1 ]; then
                    # Code to execute if condition is true
    echo "Condition is true"
	 
elif [condition2 ]; then	
	echo "Condition is true"
	
elif [condition3 ]; then	
	echo "Condition is true"	
	
else
                    # Code to execute if condition is false
    echo "Condition is false"
		
fi

==========================================
 cat person.sh


#!/bin/bash

#echo "Enter the persons age"

#read age
age=$1

if [ "$age" -gt 18 ];  then

        echo " The person is a Major"

elif [ "$age" -lt 18 ]; then

        echo "The person is Minor"

else
      echo "The person age is exactly 18 , person is a Major"

fi
=================================================
=========

#!/bin/bash

echo "enter number"
read num1

if [ "$num1" -gt 10 ]; then
        echo "$num1 is greater than 10"
		
elif [ "$num1" -lt 10 ]; then
        echo "$num1 is less than 10"

else
        echo "$num1 is 10"

fi

=========================

#!/bin/bash

number=7

if [ "$number" -gt 10 ]; then
    echo "The number is greater than 10."
	
elif [ "$number" -eq 10 ]; then
    echo "The number is exactly 10."
	
else
    echo "The number is less than 10."
fi

=================
LOOPS IN SHELL:

FOR LOOP 
WHILE LOOP
UNTIL LOOP


cat forloop.sh


#!/bin/bash

for i in {100..1}

do
     echo "The number is $i"
done

==================================================

cat whileloop.sh


#!/bin/bash

i=1


while [ "$i" -le 100  ];
do
    echo "the number is: $i"

    i=$((i + 1 ))

done

=======================================================
cat rev_while.sh


#!/bin/bash

i=100


while [ "$i" -ge 1 ];
do
    echo "the number is: $i"

    i=$((i - 1 ))

done

=====================================================
 cat untilloop.sh


#!/bin/bash

i=1

until [ "$i" -gt 100  ];
do
        echo "the number is : $i"
        i=$((i + 1))

done

======================================================
 cat rev_until.sh


#!/bin/bash

i=10

until [ "$i" -lt 1 ];
do
        echo "the number is : $i"
        i=$((i - 1))


==================================================================================================



INFINITE LOOPS 
cat infiniteloop.sh

#!/bin/bash
i=1

while [ "$i" -gt 0  ];

do
   echo "the number is : $i"
   i=$((i + 1))
done

--------------------------------------------------------------------


BREAK AND CONTINUE 

#!/bin/bash

i=1

while [ "$i" -le 100 ]; do


    if [ "$i" -eq 6 ]; then
        break  
    fi

    echo "the number is: $i"
    i=$((i + 1))

done

--------------------------------------------------------------------
#!/bin/bash

i=1

while [ "$i" -le 100 ]; do

    if [ "$i" -eq 6 ]; then
        i=$((i + 1))
        continue
    fi

    echo "the number is: $i"
    i=$((i + 1))

done
------------------------------------------------------------------------
if service_down; then
   continue   # check next service
fi

if critical_service_down; then
   break      # stop pipeline
fi

--------------------------------------------------------------------------

# BASH OPERATORS


------------------------------------------------------------
Arithmetic Operators (Numbers)
------------------------------------------------------------

       +   Addition
       -   Subtraction
       *   Multiplication
       /   Division
       %   Modulus
       **  Power

a=10
b=3

echo $((a + b))     # 13
echo $((a - b))     # 7
echo $((a * b))     # 30
echo $((a / b))     # 3
echo $((a % b))     # 1
echo $((a ** 2))    # 100


------------------------------------------------------------
Relational Operators (Numeric Comparison)
------------------------------------------------------------
# Used inside [ ]

          -eq  Equal
          -ne  Not equal
          -gt  Greater than
          -lt  Less than
          -ge  Greater or equal
          -le  Less or equal

if [ "$a" -gt "$b" ]; then
    echo "a is greater than b"
fi


------------------------------------------------------------
String Operators
------------------------------------------------------------

        =    Equal
       !=   Not equal
       -z   String is empty
       -n   String is not empty
       
name="linux"

if [ "$name" = "linux" ]; then
    echo "Correct string"
fi

------------------------------


if [ -z "$var" ]; then
    echo "Variable is empty"
fi


------------------------------------------------------------
Boolean / Logical Operators
------------------------------------------------------------

      &&   Logical AND
      ||   Logical OR
      !    Logical NOT

if [ "$a" -gt 5 ] && [ "$b" -lt 10 ]; then
    echo "Both conditions are true"
fi

if [ "$a" -lt 5 ] || [ "$b" -lt 5 ]; then
    echo "At least one condition is true"
fi


------------------------------------------------------------
File Test Operators ( Important)
------------------------------------------------------------

         -f  File exists
         -d  Directory exists
         -e  File or directory exists
         -r  Readable
         -w  Writable
         -x  Executable
         -s  File not empty
         
if [ -f "/etc/passwd" ]; then
    echo "File exists"
fi


------------------------------------------------------------
Increment / Decrement Operators
------------------------------------------------------------

i=1


i= $((i + 1))
((i++))   # Post-increment
((++i))   # Pre-increment
((i--))   # Decrement

echo "i value: $i"


------------------------------------------------------------
Assignment Operators
------------------------------------------------------------

x=10

((x+=5))    # x = x + 5
((x-=2))    # x = x - 2
((x*=2))    # x = x * 2
((x/=2))    # x = x / 2

echo "x value: $x"


------------------------------------------------------------
Bitwise Operators 
------------------------------------------------------------

# &   AND
# |   OR
# ^   XOR
# ~   NOT
# <<  Left shift
# >>  Right shift

echo $((5 & 3))     # 1
echo $((5 | 3))     # 7


------------------------------------------------------------
Command Logical Operators
------------------------------------------------------------

# &&  Run next command if success
# ||  Run next command if failure
# ;   Run regardless

mkdir test_dir && cd test_dir
ls /not_exist || echo "Command failed"

ls && ll

lm && ll

lm || ll

ll; ls; lm; pwd



------------------------------------------------------------
Production Best Practices

--------------------------------------
# Always quote variables  --> ex  rm "$file"

file="Madhu kiran"

rm "$file"

rm "Madhu kiran" 
--------------------------------------

# Use [[ ]] instead of [ ]
--------------------------------------
# Use (( )) for arithmetic

            count=5         
         if [ "$count" -gt 3 ]; then      
		 if (( count > 3 )); then
             echo "Greater"
         fi 
		 	
		 
 --------------------------------
		 count=$((count + 1))      
		 ((count++))
--------------------------------------

		
# Use set -euo pipefail

set -euo pipefail 

set -e
set -u 
set -o pipefail
set -x 


-e → Exit on error
----------------
-u → Fail on unset variables

        set -u
		
		
		
        echo "Deploying to $ENV"
----------------

set -o pipefail

cat file.txt | grep error
-------------------------------  

cat /etc/os-release

=======================================================================


--------------------------------------------------------------------
Checking command success:


docker ps >/dev/null 2>&1

if [ $? -ne 0 ]; then
  echo "Docker not running"
  exit 1
fi
--------------------------------------------------------------------
user details using for loop:

for user in $(cut -d: -f1 /etc/passwd); do
  echo "THE USER NAME IS l $user"
done


=============

---------------------
PATH

The PATH variable is a specific type of environment variable that determines the directories where executable files are searched for when you type a command in the shell without specifying its full path.

  If PATH is set to /usr/local/bin:/usr/bin:/bin, and you type ls, the system will look for ls in /usr/local/bin, then /usr/bin, and finally /bin.

ls 

lm

PATH=
/root/.local/bin:
/root/bin:
/usr/local/sbin:
/usr/local/bin:
/usr/sbin:
/usr/bin

/usr/bin/ls 

PATH=/home/ec2-user/.local/bin:/home/ec2-user/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin
==================================








